---
layout: post
title: "First Try: Ray-Tracer Targeted on Spheres and Cubes"
modified: 2017-11-24
categories:
  - Miscellanea
---


实现光线与Sphere与Cube的相交问题，其中intersection with cube通过变换座标系解决，相比教材中的方法（three pairs of slabs）降低了计算逻辑的复杂性，减少了计算开销。

## Intersection with spheres
与sphere的相交问题比较简单，只需要考虑入射光线与球心的距离即可。
```cpp
class Sphere : public Object {
public:
    float radius, radius2;
    Sphere(const Vec3f& c, const float& r,
           const Vec3f& sfC, const float& ref=0, const float& trans=0, const Vec3f& emC=0)
        : Object(c, sfC, ref, trans, emC) {
            radius = r, radius2 = r * r;
        }

    bool intersect(const Vec3f& rayOrig, const Vec3f& rayDir,  float& t0,  float& t1, Vec3f& n0, Vec3f& n1 ) const {
        Vec3f l = center - rayOrig;
        float dist = l.dot(rayDir);
        if (dist < 0) return false;
        float toCenter2 = l.dot(l) - dist*dist;
        if (toCenter2 > radius2) return false;
        float halfway = sqrt(radius2 - toCenter2);
        t0 = dist - halfway;
        t1 = dist + halfway;
        n0 = rayDir * t0 + rayOrig - center;
        n0.normalize();
        n1 = rayDir * t1 + rayOrig - center;
        n1.normalize();
        return true;
    }
};
```

## Intersection with cubes
与立方体的相交问题比较经典的做法是将其考虑为三组平面的交叉（3 pairs of slabs），找到光线与每组平面的最远入射点和最近出射点作为光线与立方体的交点，但是存在的问题是这种做法需要额外判断交点是否在立方体表面。因此另一种做法是以立方体的三条棱为座标系的三个轴，如此
可以简化计算：

```cpp
class Cube : public Object{//slabs
public:
    Vec3f point0, point1, point2, point3;
    Mat3f changeCoord, reverseCoord;
    Vec3f newXYZ[3];
    //front-top-right:1, front-bottom-left:2, front-bottom-right:0, back-bottom-right:3
    Cube(const Vec3f& p0, const Vec3f& p1, const Vec3f& p2, const Vec3f& p3,
         const Vec3f& sfC, const float& ref=0, const float& trans=0, const Vec3f& emC=0)
            : Object( ((p2 + p3) * 0.5 + (p1 - p0) * 0.5), sfC, ref, trans, emC) {
        point0 = p0, point1 = p1, point2 = p2, point3 = p3;
        reverseCoord = Mat3f((point3 - point0).normalize(), (point2 - point0).normalize(), (point1 - point0).normalize()); // new basis
        changeCoord = reverseCoord.getInverse();
        newXYZ[0] = (changeCoord * (point3 - point0));
        newXYZ[1] = (changeCoord * (point2 - point0));
        newXYZ[2] = (changeCoord * (point1 - point0));
    }

    bool intersect(const Vec3f& rayOrig, const Vec3f& rayDir, float& t0, float& t1, Vec3f& n0, Vec3f& n1) const {
        Vec3f           newOrig (changeCoord * (rayOrig - point0));
        Vec3f           newDir  (changeCoord * rayDir);
        // Searching for `t0` and `t1`
        std::map<float, Vec3f> timeAndNormal;
        for (int i = 0; i < 3; ++i) {
           if (std::abs(newDir[i]) > MINOR){// `!= 0` means not parallel with axes
                float       tTemp ((0 - newOrig[i] ) / newDir[i]);
                Vec3f       pointTemp  (newOrig + newDir * tTemp);
                if (tTemp > 0
                        && pointTemp[(i+1)%3] <= newXYZ[(i+1)%3][(i+1)%3]
                        && pointTemp[(i+1)%3] >= 0
                        && pointTemp[(i+2)%3] <= newXYZ[(i+2)%3][(i+2)%3]
                        && pointTemp[(i+2)%3] >= 0) {
                    timeAndNormal[tTemp] = -(reverseCoord * newXYZ[i]).normalize();
                }
                tTemp = (newXYZ[i][i]- newOrig[i]) / newDir[i];
                pointTemp = newOrig + newDir * tTemp;
                if (tTemp > 0
                        && pointTemp[(i+1)%3] <= newXYZ[(i+1)%3][(i+1)%3]
                        && pointTemp[(i+1)%3] >= 0
                        && pointTemp[(i+2)%3] <= newXYZ[(i+2)%3][(i+2)%3]
                        && pointTemp[(i+2)%3] >= 0) {
                    timeAndNormal[tTemp] = (reverseCoord * newXYZ[i]).normalize();
                }
            }
        }
        if (timeAndNormal.empty()) return false;
        auto it = timeAndNormal.begin();
        if (timeAndNormal.size() < 2) { //inside
            t0 = -1, n0 = Vec3f(0);
            t1 = it->first, n1 = it->second;
            return true;
        }
        t0 = it->first, n0 = it->second;
        ++it;
        t1 = it->first, n1 = it->second;
        return true;
    }
};
```

## Genereted image
![Image of simple ray-tracer](https://github.com/PuSH-Beni/push-beni.github.io/blob/master/assets/images/cubeandsphere.jpg)
